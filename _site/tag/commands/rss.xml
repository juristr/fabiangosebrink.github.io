<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>http://fabian-gosebrink.com</title>
   
   <link>http://offering.solutions</link>
   <description>Articles about Angular & ASP.NET</description>
   <language>en-us</language>
   <managingEditor> Fabian Gosebrink</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Correct implementation of Commands in WPF</title>
	  <link>//blog/articles/2014/10/01/correct-implementation-of-commands-in-wpf/</link>
	  <author>Fabian Gosebrink</author>
	  <pubDate>2014-10-01T17:32:00+02:00</pubDate>
	  <guid>//blog/articles/2014/10/01/correct-implementation-of-commands-in-wpf/</guid>
	  <description><![CDATA[
	     <p>In this blogost I want to show you the IMHO correct implementation of Commands in WPF. Feel free to discuss :)</p>

<p>Again we will take the code from the posts before (<a href="http://offering.solutions/blog/articles/2014/09/02/how-to-make-first-steps-of-databinding-in-wpf/">Wpf Basics I</a> and <a href="http://offering.solutions/blog/articles/2014/09/14/wpf-basics-ii-the-inotifypropertychanged-interface/">Wpf Basics II</a>) and make it nicer. Well: What we did was databind a string to the UI. Then we implemented a solution for notify the UI that something changed. Everything triggered with a small timer which was doing the work for “I have something new”. But what if the user himself wants to trigger the event for “I want something to be changed”?</p>

<p>Therefore we have commands. Commands can maybe triggered from Buttons and are doing some work. In our case we will now remove the timer and give our UI a button to trigger the changes.</p>

<p>So first we get rid of our timer in the NameProvider:</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">NameProviderImpl</span> <span class="p">:</span> <span class="n">NotifyPropertyChangedBase</span><span class="p">,</span> <span class="n">INameProvider</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">string</span> <span class="n">_nameToDisplay</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">NameToDisplay</span>
    <span class="p">{</span>
        <span class="k">get</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">_nameToDisplay</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">set</span>
        <span class="p">{</span>
            <span class="n">_nameToDisplay</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
            <span class="nf">OnPropertyChanged</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">NameToDisplay</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Then we will do a namespace for our commands and add one</p>

<p><img src="/assets/articles/2014-10-01/INotify_IV.jpg" alt="Correct implementation of Commands in WPF" /></p>

<p>Important for the command is: Let it be a single class. It makes testing easier and decouples it from the viewmodel. Also let it inherit from ICommand and implement this interface. And let it inherit from your command Interface ;)</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">MyCommandImpl</span> <span class="p">:</span> <span class="n">ICommand</span><span class="p">,</span> <span class="n">IMyCommand</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">INameProvider</span> <span class="n">_nameProvider</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">CanExecute</span><span class="p">(</span><span class="kt">object</span> <span class="n">parameter</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Execute</span><span class="p">(</span><span class="kt">object</span> <span class="n">parameter</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_nameProvider</span><span class="p">.</span><span class="n">NameToDisplay</span> <span class="p">=</span> <span class="s">"Hallelujah"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="nf">MyCommandImpl</span><span class="p">(</span><span class="n">INameProvider</span> <span class="n">nameProvider</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_nameProvider</span> <span class="p">=</span> <span class="n">nameProvider</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">event</span> <span class="n">EventHandler</span> <span class="n">CanExecuteChanged</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">interface</span> <span class="n">IMyCommand</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">CanExecute</span><span class="p">(</span><span class="kt">object</span> <span class="n">parameter</span><span class="p">);</span>
    <span class="k">void</span> <span class="nf">Execute</span><span class="p">(</span><span class="kt">object</span> <span class="n">parameter</span><span class="p">);</span>
    <span class="k">event</span> <span class="n">EventHandler</span> <span class="n">CanExecuteChanged</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>So what the command offers us are two methods: “CanExecute” is giving us a bool indicating if the command can be executed or not. Based on this the button will be greyed out or not. The “CanExecuteChanged” can be fired, if something, which the CanExecute is based on, has changed and it has to be evaluated again. The button may appear not greyed out in the UI after firing this. And the execute is for executing the Command. What a surprise ;)</p>

<p>The command is only taking the nameprovider and setting the name. Exactly what the timer did before.</p>

<blockquote>
  <p>The name “Name<strong>Provider</strong>” does not match here. Because it does not provide a name to us. It is more a service. Image you would trigger like a calculation or something ;)</p>
</blockquote>

<p>So now let the viewmodel offer the command that it can be triggered from the outside:</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">MainViewModel</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">INameProvider</span> <span class="n">NameProvider</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">IMyCommand</span> <span class="n">MyCommand</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">MainViewModel</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">NameProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">NameProviderImpl</span><span class="p">();</span>
        <span class="n">MyCommand</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MyCommandImpl</span><span class="p">(</span><span class="n">NameProvider</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Now we offer the UI a NameProvider to bind on and a Command to bind on. The only thing we now have to do is bind this button to the command:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;Grid&gt;</span>
    <span class="nt">&lt;StackPanel&gt;</span>
        <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding NameProvider.NameToDisplay}"</span><span class="nt">&gt;&lt;/TextBlock&gt;</span>
        <span class="nt">&lt;Button</span> <span class="na">Command=</span><span class="s">"{Binding MyCommand}"</span> <span class="na">Height=</span><span class="s">"20"</span><span class="nt">&gt;&lt;/Button&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Grid&gt;</span></code></pre></figure>

<p>Now the command is getting executed from the button. It sets the name in the nameprovider and fires the event, that something has changed and the UI gets updated.</p>

<p>That should be it for the very basic of WPF.</p>

<p>Solution can be loaded here: <a href="/assets/articles/2014-10-01/DataBindingGettingStarted.zip">Correct implementation of Commands in WPF</a></p>

<p>Enjoy</p>

<p>Fabian</p>

	  ]]></description>
	</item>


</channel>
</rss>
