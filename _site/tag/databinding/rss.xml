<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>http://fabian-gosebrink.com</title>
   
   <link>http://offering.solutions</link>
   <description>Articles about Angular & ASP.NET</description>
   <language>en-us</language>
   <managingEditor> Fabian Gosebrink</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>WPF Basics II - The INotifyPropertyChanged Interface</title>
	  <link>//blog/articles/2014/09/14/wpf-basics-ii-the-inotifypropertychanged-interface/</link>
	  <author>Fabian Gosebrink</author>
	  <pubDate>2014-09-14T19:41:00+02:00</pubDate>
	  <guid>//blog/articles/2014/09/14/wpf-basics-ii-the-inotifypropertychanged-interface/</guid>
	  <description><![CDATA[
	     <blockquote>
  <p>UPDATE
Check the CallMemberName-Possibility <a href="http://offering.solutions/blog/articles/2015/02/08/wpf-callmembername-for-inotifypropertychanged/">here</a></p>
</blockquote>

<p>In the first part I told something about the databinding <a href="http://offering.solutions/blog/articles/2014/09/02/how-to-make-first-steps-of-databinding-in-wpf/">here</a>. The second part should be something about refreshing the data at the UI. We said that the UI only knows the datacontext and its properties. So far so god. It is binding them at startup and we’re done so far.</p>

<p>Just to calm down the ones who expect a solution: Can be found in the third article <a href="http://offering.solutions/blog/articles/2014/10/01/correct-implementation-of-commands-in-wpf/">here</a></p>

<p>But what if the data underneath is changing. What if a service or anything else has new data and want to tell the UI “Hey there, I have something new!”</p>

<p>Therefore the binding has to be “refreshed” and we have the INotifyPropertyChanged-Interface to get this job done.</p>

<p>Lets take our code from before and give it a timer which sets the name we want to display after 3 seconds:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;Grid&gt;</span>
    <span class="nt">&lt;StackPanel&gt;</span>
        <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding NameToDisplay}"</span><span class="nt">&gt;&lt;/TextBlock&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Grid&gt;</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">MainViewModel</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">NameToDisplay</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Timer</span> <span class="n">_timer</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">MainViewModel</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_timer</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Timer</span><span class="p">(</span><span class="m">3000</span><span class="p">);</span>
        <span class="n">_timer</span><span class="p">.</span><span class="n">Elapsed</span> <span class="p">+=</span> <span class="n">timer_Elapsed</span><span class="p">;</span>
        <span class="n">_timer</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">timer_Elapsed</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">ElapsedEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">NameToDisplay</span> <span class="p">=</span> <span class="s">"Hallelujah"</span><span class="p">;</span>
        <span class="n">_timer</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<blockquote>
  <p> ”Hallelujah” is always my testword because im pretty sure it occurs nowhere else in a solution ;) So if you see this, its mine</p>
</blockquote>

<p>So, if you debug this you will see that the timer gets into the timer_elapsed-function and sets the name but the UI does not change. So lets implement a way to refresh the UI! Only implement the INotifyPropertyChanged-interface:</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">MainViewModel</span> <span class="p">:</span> <span class="n">INotifyPropertyChanged</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">NameToDisplay</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">readonly</span> <span class="n">Timer</span> <span class="n">_timer</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">MainViewModel</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_timer</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Timer</span><span class="p">(</span><span class="m">3000</span><span class="p">);</span>
        <span class="n">_timer</span><span class="p">.</span><span class="n">Elapsed</span> <span class="p">+=</span> <span class="n">timer_Elapsed</span><span class="p">;</span>
        <span class="n">_timer</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">timer_Elapsed</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">ElapsedEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">NameToDisplay</span> <span class="p">=</span> <span class="s">"Hallelujah"</span><span class="p">;</span>
        <span class="n">_timer</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">PropertyChanged</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">PropertyChanged</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">new</span> <span class="nf">PropertyChangedEventArgs</span><span class="p">(</span><span class="s">"NameToDisplay"</span><span class="p">));</span>
        <span class="p">}</span>
        
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">event</span> <span class="n">PropertyChangedEventHandler</span> <span class="n">PropertyChanged</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>So everthing we do is throwing the event that something has changed with the name of the property as a string. If you let this run you will see that the UI refreshes and after 3 seconds the “hallelujah” is displayed. But this has some disadvantages:</p>

<ul>
  <li>We are throwing the event in the timer_elapsed. So only when <strong>this</strong> is done the property is refreshed</li>
  <li>We are having the name of the property as a string in it. So renaming the property will mostly NOT rename the string. (Magic String). And the refresh does not work again.</li>
  <li>Refreshing the UI is a base function. It should be outsourced in like a base file or something.</li>
</ul>

<p>Lets tune this:</p>

<ol>
  <li>First we will make a namespace for this (I love namespaces) called “Common” and make a basefile in there.</li>
  <li>We will make this function generic expecting a lambda-Expression to erase the magic string</li>
  <li>We will call the refreshing thing in the setter of the property itself. Then its getting refreshed everytime someone in the code sets it.</li>
</ol>

<p><img src="/assets/articles/2014-09-14/INotify_I.jpg" alt="WPF Basics II - The INotifyPropertyChanged Interface" /></p>

<p>which looks like:</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">NotifyPropertyChangedBase</span> <span class="p">:</span> <span class="n">INotifyPropertyChanged</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">event</span> <span class="n">PropertyChangedEventHandler</span> <span class="n">PropertyChanged</span><span class="p">;</span>

    <span class="k">protected</span> <span class="k">virtual</span> <span class="k">void</span> <span class="n">OnPropertyChanged</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">propertyExpression</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">MemberExpression</span> <span class="n">memberExpr</span> <span class="p">=</span> <span class="n">propertyExpression</span><span class="p">.</span><span class="n">Body</span> <span class="k">as</span> <span class="n">MemberExpression</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">memberExpr</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="s">"Wrong PropertyExpression"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">PropertyChangedEventHandler</span> <span class="n">handler</span> <span class="p">=</span> <span class="n">PropertyChanged</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">handler</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">handler</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">new</span> <span class="nf">PropertyChangedEventArgs</span><span class="p">(</span><span class="n">memberExpr</span><span class="p">.</span><span class="n">Member</span><span class="p">.</span><span class="n">Name</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This is taking the member and throwing the event for us on this member. That was Point 1 and 2. Let it be (three)!</p>

<p>We do inherit from the just created class and can access the event with the lambda-expression, which is more generic:</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">MainViewModel</span> <span class="p">:</span> <span class="n">NotifyPropertyChangedBase</span>
<span class="p">{</span>
    <span class="k">readonly</span> <span class="n">Timer</span> <span class="n">_timer</span><span class="p">;</span>
    <span class="k">private</span> <span class="kt">string</span> <span class="n">_nameToDisplay</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">NameToDisplay</span>
    <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_nameToDisplay</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span>
        <span class="p">{</span>
            <span class="n">_nameToDisplay</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
            <span class="nf">OnPropertyChanged</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">NameToDisplay</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="nf">MainViewModel</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_timer</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Timer</span><span class="p">(</span><span class="m">3000</span><span class="p">);</span>
        <span class="n">_timer</span><span class="p">.</span><span class="n">Elapsed</span> <span class="p">+=</span> <span class="n">timer_Elapsed</span><span class="p">;</span>
        <span class="n">_timer</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">timer_Elapsed</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">ElapsedEventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">NameToDisplay</span> <span class="p">=</span> <span class="s">"Hallelujah"</span><span class="p">;</span>
        <span class="n">_timer</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Remeber: In the elapsed-method we are setting the property (not the private variable) directly that the setter is called and the event is thrown.</p>

<blockquote>
  <p>This is not the only way to implement this. This can be done in several ways. But for beginners this should do the trick.</p>
</blockquote>

<p>Run it, it will show you the text after three seconds.</p>

<p>If you want to, read further how you can get this cleaner with services and erase the NotifyPropertyChangedBase from the viewmodel.</p>

<p>Lets tune this a little bit: The viewmodel does a lot of work. It does not have to do this, so lets extract this a bit and make it more clean.</p>

<p>First we do a NameProvider, which gives us the name. In my case again with a timer to see the UI changing. Normally this could be a service or something else without a timer. Could be anything which triggers the UI to change (not only) after a piece of work.</p>

<p><img src="/assets/articles/2014-09-14/INotify_II.jpg" alt="WPF Basics II - The INotifyPropertyChanged Interface" /></p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">NameProviderImpl</span> <span class="p">:</span> <span class="n">NotifyPropertyChangedBase</span><span class="p">,</span> <span class="n">INameProvider</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">Timer</span> <span class="n">_timer</span><span class="p">;</span>
        <span class="k">private</span> <span class="kt">string</span> <span class="n">_nameToDisplay</span><span class="p">;</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">NameToDisplay</span>
        <span class="p">{</span>
            <span class="k">get</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">_nameToDisplay</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">private</span> <span class="k">set</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">_nameToDisplay</span> <span class="p">==</span> <span class="k">value</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">_nameToDisplay</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
                <span class="nf">OnPropertyChanged</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">NameToDisplay</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="nf">NameProviderImpl</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">_timer</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Timer</span><span class="p">(</span><span class="m">3000</span><span class="p">);</span>
            <span class="n">_timer</span><span class="p">.</span><span class="n">Elapsed</span> <span class="p">+=</span> <span class="n">timer_Elapsed</span><span class="p">;</span>
            <span class="n">_timer</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">void</span> <span class="nf">timer_Elapsed</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">ElapsedEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">NameToDisplay</span> <span class="p">=</span> <span class="s">"Hallelujah"</span><span class="p">;</span>
            <span class="n">_timer</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">interface</span> <span class="n">INameProvider</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">NameToDisplay</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Everything we did here is moving the timer-logic into a provider and offering the property through an interface to the outside.</p>

<p>Our viewmodel now has nearly no logic anymore:</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">MainViewModel</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">INameProvider</span> <span class="n">NameProvider</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">MainViewModel</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">NameProvider</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">NameProviderImpl</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This principle I am also describing <a href="http://offering.solutions/blog/articles/2014/07/03/clean-your-viewmodel-in-wpf-and-create-a-facade/">here</a>.</p>

<p>Now we have to change the binding a bit. Because now the viewmodel is giving us the property to bind not directly but onto another property “NameProvider”. So the Binding looks like this:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;Grid&gt;</span>
    <span class="nt">&lt;StackPanel&gt;</span>
        <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding NameProvider.NameToDisplay}"</span><span class="nt">&gt;&lt;/TextBlock&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Grid&gt;</span></code></pre></figure>

<p>Run this and you will see the result stays the same: After three seconds our string is displayed.</p>

<p><img src="/assets/articles/2014-09-14/INotify_III.jpg" alt="WPF Basics II - The INotifyPropertyChanged Interface" /></p>

<p>So what we did now is: Getting our Viewmodel nice and clean. It gives us an overview of services and providers which the UI can use. It does not inherit from NotifyPropertyChangedBase. You saw how flexible databinding is. Not only with strings but you can bind also lists of objects etc.</p>

	  ]]></description>
	</item>

	<item>
	  <title>How to make first steps of Databinding in WPF</title>
	  <link>//blog/articles/2014/09/02/how-to-make-first-steps-of-databinding-in-wpf/</link>
	  <author>Fabian Gosebrink</author>
	  <pubDate>2014-09-02T03:24:00+02:00</pubDate>
	  <guid>//blog/articles/2014/09/02/how-to-make-first-steps-of-databinding-in-wpf/</guid>
	  <description><![CDATA[
	     <p>In this blogpost I want to show you how to make first steps of Databinding in WPF.</p>

<p>I often hear or see that people try to start with WPF but they do not start mit MVVM. Because databinding is frightening them. But why? Databinding is one of the biggest advantages you can have to decouple your logic from your view.</p>

<p>With this post I want to give you a short introduction about databinding and how to get set up.</p>

<h3 id="first-things-first-why-mvvm">First things first: Why MVVM?</h3>

<p>In the last time the MV*-Pattern was really getting pushed and was established because it gives you an easy possibility to divide your view form the logic which works underneath. In the web for example AngularJS gives you a lightweight MVVM-Pattern, ASP.NET works with the MVC-Pattern, wich also brings a separation between UI and Logic.</p>

<p>Advantages are:</p>

<ul>
  <li>
    <p>Changing the UI without changing the logic: The UI changes more often than the logic. What if green is more “stylish” than the good old “blue”? It has to be changed, but all the things you show stay the same. Just because something looks different you are not showing different information.</p>
  </li>
  <li>
    <p>Testability of the logic: Because logic gets more modular it can be well tested. You do not need to know about your view or how it looks like. The only thing your tests are interested in are the output-information.</p>
  </li>
  <li>
    <p>Better overview: You can not only seperate the UI and the logic, you can also see it in the code. you have no UI-Code in your logic and no logic-code in your UI.</p>
  </li>
  <li>
    <p>Different Teams: Also in SCRUM or whatever you use you can easily divide the work into several parts. UI Designers can only focus on their work, while programmers code (and test) the work completetly different. The touching points are only made because of the DataBinding.</p>
  </li>
</ul>

<h3 id="theoretically-what-are-we-doing">Theoretically: What are we doing?</h3>

<p>In Wpf and C# the UI-files are described as *.xaml-files. The viewmodels are normal classes which are *.cs-files. You can connect them via the DataContext-property. This shall point on the ViewModel we are creating for it. (Also described <a title="WPF – Introducing services in the viewmodel (viewmodel as facade)" href="http://offering.solutions/blog/articles/2014/07/03/clean-your-viewmodel-in-wpf-and-create-a-facade/" target="_blank">here</a>)</p>

<p>The code-behind of a window stays empty. No matter what. There are cases to really do some work there but these are very rare!</p>

<h3 id="lets-see-some-code">Lets see some code:</h3>

<p>Well if you only add a xaml-file or open a new wpf project in visual studio you can add a normal textblock to your xaml like this.</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;Window</span> <span class="na">x:Class=</span><span class="s">"DataBindingGettingStarted.MainWindow"</span>
        <span class="na">xmlns=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
        <span class="na">xmlns:x=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml"</span>
        <span class="na">Title=</span><span class="s">"MainWindow"</span> <span class="na">Height=</span><span class="s">"350"</span> <span class="na">Width=</span><span class="s">"525"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
        <span class="nt">&lt;TextBlock&gt;&lt;/TextBlock&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Window&gt;</span></code></pre></figure>

<p>Now add a binding to it. Want we want to do is bind the Text-Property of the TextBlock to a value from the viewmodel. Lets prepare our XAML:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;Window</span> <span class="na">x:Class=</span><span class="s">"DataBindingGettingStarted.MainWindow"</span>
        <span class="na">xmlns=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
        <span class="na">xmlns:x=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml"</span>
        <span class="na">Title=</span><span class="s">"MainWindow"</span> <span class="na">Height=</span><span class="s">"350"</span> <span class="na">Width=</span><span class="s">"525"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
        <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding NameToDisplay}"</span><span class="nt">&gt;&lt;/TextBlock&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Window&gt;</span></code></pre></figure>

<p>Now lets do the viewmodel. This is the base for our databinding. Its a normal class. Remember to name it like the view to associate it easier for other developers.</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">MainViewModel</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">NameToDisplay</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">MainViewModel</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">NameToDisplay</span> <span class="p">=</span> <span class="s">"Hello World"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Remeber: This is an external class. It has “nothing” to do (yet) with the UI. There is no connection until here. In a project this could look like this:</p>

<p><img src="/assets/articles/2014-09-02/DataBinding1.jpg" alt="How to make first steps of Databinding in WPF" /></p>

<p>The viewmodel offers all data it wants to show to the view (and perhaps some more ;) ). These data are offered with properties.</p>

<blockquote>
  <p>Note: You can make an interface for the viewmodel to see what exactly is on the view and what is not. To get a besser overview. But internally wpf will take the real implementaion of the viewmodel as datacontext. But for larger view/viewmodels adding an interface can makes sense. Also for testing/mocking etc.</p>
</blockquote>

<p>You see that the MainWindow.xaml which we edited above and the viewmodel. We just have no connection until here.</p>

<p>In the last part you have to let the view know about its datacontext. This property can be set to nearly every viewmodel but its the source for the view where to get their data from. So the “Text”-Property in XAML gets its value from…what? You can set the datacontext in XAML but I think its easier to set this in the codebehind. <strong><span style="text-decoration: underline;">This is the only thing you should set there!</span></strong></p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MainWindow</span> <span class="p">:</span> <span class="n">Window</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">MainWindow</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nf">InitializeComponent</span><span class="p">();</span>
        <span class="n">DataContext</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MainViewModel</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>And there you go. Now the view does know about the datacontext which is completely seperated. It is offering the information about properties and if you press F5 to run the solution you should see something like this:</p>

<p><img src="/assets/articles/2014-09-02/DataBinding2.jpg" alt="How to make first steps of Databinding in WPF" /></p>

<p>Now what we did is a normal Hello-World-Label. Depending on the UI-container (ItemControls, Comboboxes,…) you can bind whatever you want to the UI.</p>

<p>This is it for the first shot of databinding. But this is only the basic basic ;). But I wanted you to get the point.</p>

<p>Regards</p>

<p>Fabian</p>

<p> </p>

<p>[UPDATE]</p>

<p>I decided to go on and show you how to bind a list of any objects you want. In my example these are hard coded. In your example they can (and should ;) ) come from a service/repository whatever.</p>

<p>First lets expand the viewmodel with a Person-class which has two properties: Name and Age.</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">MainViewModel</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">NameToDisplay</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;</span> <span class="n">ListOfPersons</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">MainViewModel</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">NameToDisplay</span> <span class="p">=</span> <span class="s">"Hello World"</span><span class="p">;</span>
        <span class="n">ListOfPersons</span> <span class="p">=</span> <span class="nf">GetListOfPersons</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;</span> <span class="nf">GetListOfPersons</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Person</span> <span class="n">fabianPerson</span> <span class="p">=</span> <span class="nf">GetPerson</span><span class="p">(</span><span class="s">"Fabian"</span><span class="p">,</span> <span class="m">29</span><span class="p">);</span>
        <span class="n">Person</span> <span class="n">evePerson</span> <span class="p">=</span> <span class="nf">GetPerson</span><span class="p">(</span><span class="s">"Eve"</span><span class="p">,</span> <span class="m">100</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;</span> <span class="p">{</span><span class="n">fabianPerson</span><span class="p">,</span> <span class="n">evePerson</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">Person</span> <span class="nf">GetPerson</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Person</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">Person</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">Age</span> <span class="p">=</span> <span class="n">age</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>So right like the plain name we are offering a list of persons at the viewmodel.</p>

<p>Now that the viewmodel is our Datacontext it can access every property on it. So lets access this in XAML:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;Grid&gt;</span>
    <span class="nt">&lt;StackPanel&gt;</span>
        <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding NameToDisplay}"</span><span class="nt">&gt;&lt;/TextBlock&gt;</span>
        <span class="nt">&lt;ItemsControl</span> <span class="na">ItemsSource=</span><span class="s">"{Binding ListOfPersons}"</span><span class="nt">&gt;</span>
            
        <span class="nt">&lt;/ItemsControl&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Grid&gt;</span></code></pre></figure>

<p>But if you run this you only see the namespace and the name of the classes. Why this? Because the only thing you give to the ItemsControl is the list of persons. From where should it know what to do with it? It just calls the “ToString()”-Extension on “object” and gets the Namespace and the name of the class.</p>

<p><img src="/assets/articles/2014-09-02/List1.jpg" alt="How to make first steps of Databinding in WPF" /></p>

<p>So lets tell the UI how to treat the objects. This can be done with an Itemtemplate.</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;Window.Resources&gt;</span>
    <span class="nt">&lt;DataTemplate</span> <span class="na">x:Key=</span><span class="s">"MyItemTemplate"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;StackPanel</span> <span class="na">Orientation=</span><span class="s">"Horizontal"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Label</span> <span class="na">Content=</span><span class="s">"{Binding Name}"</span><span class="nt">&gt;&lt;/Label&gt;</span>
            <span class="nt">&lt;Label</span> <span class="na">Content=</span><span class="s">"{Binding Age}"</span><span class="nt">&gt;&lt;/Label&gt;</span>
        <span class="nt">&lt;/StackPanel&gt;</span>
    <span class="nt">&lt;/DataTemplate&gt;</span>
<span class="nt">&lt;/Window.Resources&gt;</span>
<span class="nt">&lt;Grid&gt;</span>
    <span class="nt">&lt;StackPanel&gt;</span>
        <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding NameToDisplay}"</span><span class="nt">&gt;&lt;/TextBlock&gt;</span>
        <span class="nt">&lt;ItemsControl</span> <span class="na">ItemsSource=</span><span class="s">"{Binding ListOfPersons}"</span> <span class="na">ItemTemplate=</span><span class="s">"{StaticResource MyItemTemplate}"</span><span class="nt">&gt;</span>
            
        <span class="nt">&lt;/ItemsControl&gt;</span>
    <span class="nt">&lt;/StackPanel&gt;</span>
<span class="nt">&lt;/Grid&gt;</span></code></pre></figure>

<p>The Itemtemplate now tells the object how to appear. In my case these are just two labels showing the two properties name and age.</p>

<blockquote>
  <p><span style="color: #000000;">I dont know why but this is a heavy thing every beginner stumbles upon: The Datacontext of you <strong>view **is what we have set it to: The MainViewModel. Now you give the collection to the ItemsControl and make an **Item</strong>Template for each object in the list. So in the <strong>Item</strong>Template the “datacontext” is the object “Person” itself and NOT the MainViewModel anymore! This is why you can access “Name” and “Age” in the DataTemplate directly. Because every Item (which the <strong>Item</strong>Template is for) is a Person and a Person has got the mentioned properties.</span></p>
</blockquote>

<p>Great. After telling this let this thing run and see the result:</p>

<p><img src="/assets/articles/2014-09-02/List2.jpg" alt="How to make first steps of Databinding in WPF" /></p>

<p>Have fun</p>

<p>Fabian</p>

	  ]]></description>
	</item>

	<item>
	  <title>Clean your viewmodel in WPF and create a facade</title>
	  <link>//blog/articles/2014/07/03/clean-your-viewmodel-in-wpf-and-create-a-facade/</link>
	  <author>Fabian Gosebrink</author>
	  <pubDate>2014-07-03T17:51:00+02:00</pubDate>
	  <guid>//blog/articles/2014/07/03/clean-your-viewmodel-in-wpf-and-create-a-facade/</guid>
	  <description><![CDATA[
	     <p>In this post I want to show you how to Clean your viewmodel in WPF and create a facade.</p>

<p>We use a facade to get your viewmodel in WPF nice and clean. I want to show you how to get along with the seperation of concerns and how to write simple and testable code with databinding and WPF.</p>

<p>When you want to use a viewmodel for databinding you normally get your public properties on your viewmodel an do a normal binding on your xaml like this:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;Window</span> <span class="na">x:Class=</span><span class="s">"WPFViewModelAsFacade.MainWindow"</span>
        <span class="na">xmlns=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
        <span class="na">xmlns:x=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml"</span>
        <span class="na">Title=</span><span class="s">"MainWindow"</span> <span class="na">Height=</span><span class="s">"350"</span> <span class="na">Width=</span><span class="s">"525"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
        <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding MyCalculatedNumber}"</span><span class="nt">&gt;&lt;/TextBlock&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Window&gt;</span></code></pre></figure>

<p>Setting the datacontext:</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MainWindow</span> <span class="p">:</span> <span class="n">Window</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">MainWindow</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">InitializeComponent</span><span class="p">();</span>
            <span class="n">DataContext</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MainViewModel</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p>and your viewmodel something like:</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">MainViewModel</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="kt">int</span> <span class="n">_myCalculatedNumber</span><span class="p">;</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="n">MyCalculatedNumber</span>
        <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_myCalculatedNumber</span><span class="p">;</span> <span class="p">}</span>
            <span class="k">set</span> <span class="p">{</span> <span class="n">_myCalculatedNumber</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">//other Properties here...
</span>
        <span class="k">public</span> <span class="nf">MainViewModel</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">_myCalculatedNumber</span> <span class="p">=</span> <span class="m">23</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p>of course you would give the viewmodel other values and it would grow like hell. Also when you do calculations or CRUD-operations etc. But when your application grows and gets bigger it would be necessary to move some thing into services, providers etc. to get into the seperation of concerns.</p>

<h3 id="solution-i---services">Solution I -  Services</h3>

<p>So lets introduce a service to do some work (a normal calculation with the result of 23 in my example):</p>

<p><img src="/assets/articles/2014-07-03/1.jpg" alt="clean your viewmodel in WPF and create a facade" /></p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">namespace</span> <span class="nn">WPFViewModelAsFacade</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">interface</span> <span class="n">ICalculationService</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="nf">CalculateNumber</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">namespace</span> <span class="nn">WPFViewModelAsFacade</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">CalculationService</span> <span class="p">:</span> <span class="n">ICalculationService</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="nf">CalculateNumber</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="c1">//do some calculation/work
</span>            <span class="c1">//return result...
</span>            <span class="k">return</span> <span class="m">23</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>And your viewmodel could look like this</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">namespace</span> <span class="nn">WPFViewModelAsFacade</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">MainViewModel</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="kt">int</span> <span class="n">_myCalculatedNumber</span><span class="p">;</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="n">MyCalculatedNumber</span>
        <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_myCalculatedNumber</span><span class="p">;</span> <span class="p">}</span>
            <span class="k">set</span> <span class="p">{</span> <span class="n">_myCalculatedNumber</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">//other Properties here...
</span>
        <span class="k">public</span> <span class="nf">MainViewModel</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">ICalculationService</span> <span class="n">calculationService</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CalculationService</span><span class="p">();</span>
            <span class="n">_myCalculatedNumber</span> <span class="p">=</span> <span class="n">calculationService</span><span class="p">.</span><span class="nf">CalculateNumber</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><span style="color: #999999;">Note: Normally you would use dependency injection here to avoid this “new …” call and a link to the direct implementation of the service.</span></p>

<p>So: Now we have outsourced the calculation and introduced a new service which is doing the work. But this is not a facade. Our viewmodel is still very big (image it bigger than it looks here: There are a lot more properties on it in a real application).</p>

<h3 id="solution-ii---facade">Solution II - Facade</h3>

<p>The viewmodel should now get a real facade and only offer the service which is doing the calculation. This makes you more flexible and the viewmodel is like only an interface for the view. Its like a provider for every service (or providers) which contain the information the view needs.</p>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">namespace</span> <span class="nn">WPFViewModelAsFacade</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">interface</span> <span class="n">ICalculationService</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">CalculatedNumber</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">namespace</span> <span class="nn">WPFViewModelAsFacade</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">CalculationService</span> <span class="p">:</span> <span class="n">ICalculationService</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">CalculatedNumber</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="nf">CalculationService</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="c1">// Do some stuff here and get the result in the defined property
</span>            <span class="n">CalculatedNumber</span> <span class="p">=</span> <span class="m">25</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">MainViewModel</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ICalculationService</span> <span class="n">_calculationService</span><span class="p">;</span>
    <span class="c1">//other Properties here...
</span>
    <span class="k">public</span> <span class="n">ICalculationService</span> <span class="n">CalculationService</span>
    <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_calculationService</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="nf">MainViewModel</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_calculationService</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CalculationService</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>So far until here. What we did is: We are only offering the service through our viewmodel and our viewmodel is not interested in what happens behind anymore. The service can do his work and only give back his results. But you have to correct you binding now because your number is not in the viewmodel anymore but in the service behind.</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;Window</span> <span class="na">x:Class=</span><span class="s">"WPFViewModelAsFacade.MainWindow"</span>
        <span class="na">xmlns=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
        <span class="na">xmlns:x=</span><span class="s">"http://schemas.microsoft.com/winfx/2006/xaml"</span>
        <span class="na">Title=</span><span class="s">"MainWindow"</span> <span class="na">Height=</span><span class="s">"350"</span> <span class="na">Width=</span><span class="s">"525"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Grid&gt;</span>
        <span class="nt">&lt;TextBlock</span> <span class="na">Text=</span><span class="s">"{Binding CalculationService.CalculatedNumber}"</span><span class="nt">&gt;&lt;/TextBlock&gt;</span>
    <span class="nt">&lt;/Grid&gt;</span>
<span class="nt">&lt;/Window&gt;</span></code></pre></figure>

<p>We are now bind on our service “.” our property. Its the same with Commands. Commands should be seperate classes (in a seperated namespace) and you be offered through the viewmodel.</p>

<p>If you do this your viewmodel gets a complete facade and you can change the services underneath without touching the viewmodel. So every testcase you write for the viewmodel would be untouched :)</p>

<p>Note: Your viewmodel does not have to implement INotifypropertyChanged then. If you make classes/interfaces which are providing informations to the UI these classes are the only ones who have to implement INotifyPropertyChanged.</p>

<p>If you think further it would be better to seperate the service one again and getting a provider between the service, which is doing the real job and the class/interface, which is giving the data to the outside world. This provider (or however you call it) can then be offered in the viewmodel and you would bind first over this one. But for now this should be it, I think you got my point ;) .</p>

<p><img src="/assets/articles/2014-07-03/2.jpg" alt="clean your viewmodel in WPF and create a facade" />
<img src="/assets/articles/2014-07-03/Facade.jpg" alt="clean your viewmodel in WPF and create a facade" /></p>

<p><a href="/assets/articles/2014-07-03/WPFViewModelAsFacade.zip">WPFViewModelAsFacade Solution</a></p>

	  ]]></description>
	</item>


</channel>
</rss>
